#!/usr/bin/env perl
use warnings;
use strict;
use open qw(locale);
our $PROGNAME = basename($0);

use File::Basename qw(basename);
use POSIX qw(dup2);

STDOUT->autoflush(1);
STDERR->autoflush(1);

our %options;
our @gitCmd = ('git', 'log', '--parents', '--color=always');

use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'all'               => sub { push(@gitCmd, '--all'); },
    'decorate:s'        => sub { if ($_[1] =~ m{\S}) { push(@gitCmd, '--decorate=' . $_[1]); } else { push(@gitCmd, '--decorate'); } },
    'no-decorate'       => sub { push(@gitCmd, '--no-decorate'); },
    'date-order'        => sub { push(@gitCmd, '--date-order'); },
    'author-date-order' => sub { push(@gitCmd, '--author-date-order'); },
    'topo-order'        => sub { push(@gitCmd, '--topo-order'); },
    'pretty:s'          => sub { if ($_[1] =~ m{\S}) { push(@gitCmd, '--pretty=' . $_[1]); } else { push(@gitCmd, '--pretty'); } },
    'format=s'          => sub { push(@gitCmd, '--format=' . $_[1]); },
    'abbrev-commit'     => sub { push(@gitCmd, '--abbrev-commit'); },
    'no-abbrev-commit'  => sub { push(@gitCmd, '--no-abbrev-commit'); },
    'oneline'           => sub { push(@gitCmd, '--oneline'); },
    'date=s'            => sub { push(@gitCmd, '--date=' . $_[1]); },
    'parents'           => sub { $options{parents} = 1; },
    'name-status'       => sub { push(@gitCmd, '--name-status'); },
    #'no-color'          => sub { push(@gitCmd, '--no-color'); },
    'abbrev:s'          => sub { $options{abbrev} = $_[1] if $_[1] =~ m{\S};
                                 if ($_[1] =~ m{\S}) { push(@gitCmd, '--abbrev=' . $_[1]); } else { push(@gitCmd, '--abbrev'); } },
    'graph'             => sub { }, # no effect
    'adog|goad'         => sub { push(@gitCmd, '--oneline', '--all', '--decorate'); },

    # our options
    'narrow'            => sub { $options{colSep} = 2; },
    'test'              => sub { $options{test} = 1; },
    'stdin'             => sub { $options{stdin} = 1; },
    'help'              => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage: ${PROGNAME} [<option> ...]
    --adog, --goad   sets --oneline, --all, --decorate
    --stdin          read git log --parents output from stdin
    --help           print this message
git-log(1) options accepted:
    --all
    --decorate[=<short|full|auto|no>], --no-decorate
    --date-order, --author-date-order, --topo-order
    --pretty[=<format>], --format=<format>, --oneline
    --abbrev-commit, --no-abbrev-commit
    --date=<format>
    --name-status
    --no-color
    --abbrev[=<n>]
    --parents, --graph (have no effect)
END

my $g = My::Git::Graph->new(options => \%options);

# Let's pipe our own output through a pager.
if (-t fileno(\*STDOUT)) {
    my $pager = $ENV{GIT_VGRAPH_PAGER} // $ENV{GIT_PAGER} // $ENV{PAGER} // 'less';
    my ($childIn, $parentOut);
    pipe($childIn, $parentOut) or die("pipe: $!");
    my $pid = fork();
    die("fork: $!") if !defined $pid;
    if ($pid) {
        dup2(fileno($childIn), 0) or die("dup2: $!");
        exec($pager) or die("exec: $!");
    }
    dup2(fileno($parentOut), 1) or die("dup2: $!");
    $g->{options}->{isPaging} = 1;
}

if ($options{stdin}) {
    while (<>) {
        $g->parseLine($_);
    }
    $g->eof();
} else {
    push(@gitCmd, @ARGV);
    my $ph;
    open($ph, '-|', @gitCmd) or die("unable to execute git log: $!\n");
    while (<$ph>) {
        $g->parseLine($_);
    }
    $g->eof();
}

package My::Git::Graph {
    use Text::Tabs qw(expand);
    use List::Util qw(min max uniq);
    use JSON;
    our $RX_ESCAPE;
    BEGIN {
        $RX_ESCAPE = qr{\e\[[0-9;]*m};
    }
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{minCol} //= 24;
        $self->{minSpace} //= 6;
        $self->{graphLines} = [];
        $self->{textLines} = [];
        $self->{fillLine} = '';
        $self->{colSep} //= ($self->{options}->{colSep} // 3);
        $self->{abbrev} //= ($self->{options}->{abbrev} // 8);
        $self->{bullet} = "\N{BLACK CIRCLE}";
        $self->{abbrev} //= 1 if $self->{test};
        $self->{pri} = {};
        $self->{why} = {};
        $self->{json} = JSON->new()->ascii(1)->pretty(0)->canonical(1);
        $self->{commitCount} = 0;
        $self->{ruleCount} = 0;
        return $self;
    }
    sub parseLine {
        my ($self, $line) = @_;
        if ($self->{test}) {
            return if $line !~ m{\S};
            return if $line =~ m{^\s*#};
        }
        $line =~ s{\R\z}{};    # safer than chomp regarding \r\n vs \n
        local $_ = $line;
        $_ = expand($_);
        my $RX_COMMIT_ID = qr{[[:xdigit:]]{$self->{abbrev},}}x;
        if (m{^(?<esc1>${RX_ESCAPE})?
              (commit[ ])?
              (?<commitids>(?:${RX_COMMIT_ID})(?:[ ](?:${RX_COMMIT_ID}))*\b)
              (?<esc2>\s*${RX_ESCAPE})?
              (?<remainder>.*)$}x) {
            my $esc1      = $+{esc1};
            my $commitids = $+{commitids};
            my $esc2      = $+{esc2};
            my $remainder = $+{remainder};
            my @commitids = grep { m{\S} } split(qr{\s+}, $commitids);
            $self->startCommit(@commitids);
            if (!$self->{options}->{parents}) {
                $line = ($esc1 // '') . $commitids[0] . ($esc2 // '') . $remainder;
            }
            $self->commitLogLine($line);
        } else {
            $self->commitLogLine($line);
        }
    }
    sub startCommit {
        my ($self, $commit, $firstParent, @otherParents) = @_;
        $self->{commitCount} += 1;
        $self->printerFlush();
        my $reserved = $self->{RC} //= {};
        my $columns  = $self->{C} //= {};
        my $state1   = { %$columns };
        my $state2;
        if (!defined $columns->{$commit}) {
            $columns->{$commit} = $self->newColumn($columns);
            $state1->{$commit} = $columns->{$commit};
            if (defined $self->{orphaned}) {
                # if previous commit A had no parents and this commit B is
                # assigned same column, insert a "blank" line to render
                # properly, and not mislead people that A's parent is B.
                if ($columns->{$commit} == $self->{orphaned}) {
                    $self->printerGraph($self->{orphanLine});
                    $self->printerText('');
                }
                delete $self->{orphanLine};
                delete $self->{orphaned};
            }
        }
        if (!defined $firstParent) {
            $self->priorityUnmention($commit);
            $self->{orphaned} = $state1->{$commit};
            delete $state1->{$commit};
            my $maxCol = max grep { defined $_ } values %$columns;
            my $line1 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
            my $line2 = $self->verticalGraphLine($maxCol, $state1);
            $self->{orphanLine} = $line2; # may need later
            $self->printerFill($line2);
            $self->printerGraph($line1);
            %$columns = %$state1;
            return;
        }
        my $firstParentWasAllocated = defined $state1->{$firstParent};
        if (!$firstParentWasAllocated) {
            $state1->{$firstParent} = $columns->{$commit};
        }
        foreach my $otherParent (@otherParents) {
            if (!defined $state1->{$otherParent}) {
                $state1->{$otherParent} = $self->newColumn($state1);
            }
        }
        if ($self->isTesting) {
            $self->{appendToFirstLine} = $self->prioritiesString();
        }
        if ($firstParentWasAllocated) {
            my $col1 = $state1->{$commit};
            my $col2 = $state1->{$firstParent};
            # given commit C and first parent P, which scenario
            # do we draw?
            #   col1 col2   col1 col2
            #     C  (P)      C  (P)
            #      \ |        | /
            #       \|        |/
            #        |        |
            # The first scenario is simpler for our routines, as they
            # are, to render.
            if ($col1 ne $col2) {
                my ($winner, $loser) = $self->priorityWinner($commit, $firstParent);
                if (defined $winner && $state1->{$winner} == $col1) {
                    $state2 = { %$state1 };
                }
            }
        }
        my $maxCol = max grep { defined $_ } (values(%$columns), values(%$state1));
        my @diagLines1;
        my @diagLines2;
        if (defined $state2) {
            my $col1 = $state1->{$commit};
            my $col2 = $state1->{$firstParent};
            @diagLines1 = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, @otherParents);

            # You are not expected to understand this.
            # BEGIN HACK
            delete $state2->{$firstParent};
            @diagLines2 = $self->diagonalGraphLines($maxCol, $state1, $state2, $firstParent, $commit);
            $state2->{$firstParent} = $state2->{$commit};
            delete $state2->{$commit};
            # END HACK
        } else {
            delete $state1->{$commit};
            @diagLines1 = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, $firstParent, @otherParents);
        }
        my $fillLine = $self->verticalGraphLine($maxCol, $state2 // $state1);
        my $line0 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
        $self->printerFill($fillLine);
        $self->printerGraph($line0);
        # my @diagLines = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, $firstParent, @otherParents);
        foreach my $diagLine (@diagLines1, @diagLines2) {
            $self->printerGraph($diagLine);
        }
        $self->priorityAdd($commit, $firstParent, @otherParents);
        $self->priorityReplace($commit, $firstParent, @otherParents);
        if (defined $state2) {
            %$columns = %$state2;
        } else {
            %$columns = %$state1;
        }
    }
    sub commitLogLine {
        my ($self, $line) = @_;
        $self->printerText($line);
    }
    sub newColumn {
        my ($self, @states) = @_;
        my @columns = grep { defined $_ } map { (values(%$_)) } @states;
        my %columns = map { ($_ => 1) } @columns;
        for (my $i = 0; ; $i += 1) {
            if (!$columns{$i}) {
                return $i;
            }
        }
    }
    sub priorityWinner {
        my ($self, $a, $b) = @_;
        my $pri = $self->{pri};
        if ($pri->{$a}->{$b}) {
            return ($a, $b) if wantarray;
            return  $a;
        }
        if ($pri->{$b}->{$a}) {
            return ($b, $a) if wantarray;
            return  $b;
        }
        return;
    }
    sub prioritiesString {
        my ($self) = @_;
        return unless $self->isTesting;
        my $pri = $self->{pri};
        my @rules;
        foreach my $a (keys %$pri) {
            foreach my $b (keys %{$pri->{$a}}) {
                push(@rules, sprintf("%s > %s [%d]", $a, $b, $pri->{$a}->{$b}));
            }
        }
        return join(' ', @rules);
    }
    sub priorityAdd {
        # add A-over-B rules
        my ($self, $commit, $a, @b) = @_;
        my $pri = $self->{pri};
        foreach my $b (@b) {
            if ($pri->{$a}->{$b}) {
                next;
            }
            if ($pri->{$b}->{$a}) {
                next;
            }
            if ($a eq $b) {
                next;
            }

            my $ruleNumber = ++$self->{ruleCount};
            $pri->{$a}->{$b} = $ruleNumber;

            if ($self->isTesting) {
                my $why = $self->{why};
                $why->{$a}->{$b} = [undef, undef, $commit, $a, @b];
            }
        }
    }
    sub priorityReplace {
        my ($self, $a, $b, @p) = @_;
        my $pri = $self->{pri};

        if (!defined $b) {
            return $self->priorityUnmention($a);
        }

        # replace A-over-X rules with B-over-X rules.
        foreach my $x (keys %{$pri->{$a}}) { # iterate A-over-X rules
            delete $pri->{$a}->{$x};

            if ($pri->{$b}->{$x}) {
                next;
            }
            if ($pri->{$x}->{$b}) {
                next;
            }
            if ($b eq $x) {
                next;
            }

            my $ruleNumber = ++$self->{ruleCount};
            $pri->{$b}->{$x} = $ruleNumber;

            if ($self->isTesting) {
                my $why = $self->{why};
                $why->{$b}->{$x} = [$a, $x, $a, $b, @p];
            }
        }
        delete $pri->{$a} if !scalar keys %{$pri->{$a}};

        # replace X-over-A rules with X-over-B rules.
        foreach my $x (keys %$pri) {
            if ($pri->{$x}->{$a}) { # IFF there's an X-over-A rule ...
                delete $pri->{$x}->{$a};

                if ($pri->{$b}->{$x}) {
                    next;
                }
                if ($pri->{$x}->{$b}) {
                    next;
                }
                if ($x eq $b) {
                    next;
                }

                my $ruleNumber = ++$self->{ruleCount};
                $pri->{$x}->{$b} = $ruleNumber;

                if ($self->isTesting) {
                    my $why = $self->{why};
                    $why->{$x}->{$b} = [$x, $a, $a, $b, @p];
                }
            }
        }
    }
    sub priorityUnmention {
        my ($self, $a) = @_;
        my $pri = $self->{pri};
        delete $pri->{$a};
        foreach my $b (keys %$pri) {
            delete $pri->{$b}->{$a};
        }
        delete $pri->{$b} if !scalar keys %{$pri->{$b}};
    }
    sub printerFill {
        my ($self, $text) = @_;
        $self->{fillLine} = $text // '';
    }
    sub printerText {
        my ($self, $text) = @_;
        push(@{$self->{textLines}}, $text);
        $self->printerOut();
    }
    sub printerGraph {
        my ($self, $text) = @_;
        push(@{$self->{graphLines}}, $text);
        $self->printerOut();
    }
    sub printerOut {
        my ($self) = @_;
        my $g = $self->{graphLines};
        my $t = $self->{textLines};
        while (scalar @$g && scalar @$t) {
            my $graphLine = shift(@$g);
            my $textLine = shift(@$t);
            $self->printerPrintLine($graphLine, $textLine);
        }
    }
    sub printerFlush {
        my ($self) = @_;
        my $g = $self->{graphLines};
        my $t = $self->{textLines};
        $self->printerOut();
        while (scalar @$g || scalar @$t) {
            my $graphLine = shift(@$g);
            my $textLine = shift(@$t);
            if (defined $graphLine && defined $textLine) {
                $self->printerPrintLine($graphLine, $textLine);
            } elsif (defined $graphLine) {
                $self->printerPrintLine($graphLine, undef);
            } elsif (defined $textLine) {
                $self->printerPrintLine($self->{fillLine}, $textLine);
            }
        }
        delete $self->{appendToFirstLine};
    }
    sub printerPrintLine {
        my ($self, $graphLine, $textLine) = @_;
        return if !defined $graphLine && !defined $textLine;
        $graphLine //= '';
        $textLine //= '';
        $graphLine .= ' ' x $self->{minSpace};
        my $len = $self->printedLength($graphLine);
        if ($len < $self->{minCol}) {
            $graphLine .= ' ' x ($self->{minCol} - $len);
        }
        if (!-t 1) {
            if (!$self->{options}->{isPaging}) {
                $graphLine =~ s{\e[[0-9;]*m}{}g if defined $graphLine;
                $textLine =~ s{\e[[0-9;]*m}{}g if defined $textLine;
            }
        }
        my $outputLine = $graphLine . $textLine;
        if (defined $self->{appendToFirstLine}) {
            $outputLine .= ' ' . $self->{appendToFirstLine};
            delete $self->{appendToFirstLine};
        }
        print($outputLine, "\n");
    }
    sub printedLength {
        my ($self, $string) = @_;
        $string =~ s{${RX_ESCAPE}}{}g;
        return length $string;
    }
    sub verticalGraphLine {
        my ($self, $maxCol, $A, $mark) = @_;
        my $colSep = $self->{colSep};
        my @col = grep { defined $_ } values(%$A);
        return if !scalar @col;
        my $line = ' ' x ($maxCol * $colSep + 1);
        foreach my $col (@col) {
            substr($line, $col * $colSep, 1) = '|';
        }
        my $bullet = $self->{bullet};
        if (defined $mark) {
            substr($line, $mark * $colSep, 1) = $bullet;
        }
        $line =~ s{\Q$bullet\E}{\e[1;33m$&\e[m}g;
        return $line;
    }
    sub diagonalGraphLines {
        my ($self, $maxCol, $columns, $state1, $commit, @parents) = @_;
        if (!defined $commit && !scalar @parents) {
            return ();
        }
        my $colSep = $self->{colSep};
        my $useLine1;     # true if there's any diagonal lines at all
        my $useLine2;     # true if line2 is needed to render properly
        my $line1 = ' ' x ($maxCol * $colSep + 1);
        my $line2 = ' ' x ($maxCol * $colSep + 1);
        my @parentColumns = map { $state1->{$_} } @parents;
        my $thisColumn = $columns->{$commit};
        my @leftColumns  = grep { $_ < $thisColumn } @parentColumns;
        my @rightColumns = grep { $_ > $thisColumn } @parentColumns;

        # draw leftward downward diagonals
        if (scalar @leftColumns) {
            $useLine1 = 1;
            substr($line1, $thisColumn * $colSep - 1, 1) = '/';
            my $leftmostColumn = min @leftColumns;
            foreach my $column (@leftColumns) {
                next if $column == $thisColumn - 1 && $colSep < 3;
                $useLine2 = 1;
                substr($line2, $column * $colSep + 1, 1) = '/';
            }
            my $pos1 = $leftmostColumn * $colSep + 2;
            my $pos2 = $thisColumn * $colSep - 2;
            if ($pos1 <= $pos2) {
                substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
            }
        }

        # draw rightward downward diagonals
        if (scalar @rightColumns) {
            $useLine1 = 1;
            substr($line1, $thisColumn * $colSep + 1, 1) = '\\';
            my $rightmostColumn = max @rightColumns;
            foreach my $column (@rightColumns) {
                next if $column == $thisColumn + 1 && $colSep < 3;
                $useLine2 = 1;
                substr($line2, $column * $colSep - 1, 1) = '\\';
            }
            my $pos1 = $thisColumn * $colSep + 2;
            my $pos2 = $rightmostColumn * $colSep - 2;
            if ($pos1 <= $pos2) {
                substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
            }
        }

        # is one of the parents this column?
        if (grep { $thisColumn == $_ } @parentColumns) {
            substr($line1, $thisColumn * $colSep, 1) = '|';
            substr($line2, $thisColumn * $colSep, 1) = '|';
        }

        my @verticalCommits = grep { defined $columns->{$_} } keys %$state1;
        my @verticalColumns = map { $columns->{$_} } @verticalCommits;
        foreach my $column (@verticalColumns) {
            substr($line1, $column * $colSep, 1) = '|';
            substr($line2, $column * $colSep, 1) = '|';
        }
        return ($line1, $line2) if $useLine2;
        return ($line1) if $useLine1;
        return ();
    }
    sub eof {
        my ($self) = @_;
        $self->printerFlush();
    }
    sub isTesting { return shift()->{options}->{test}; }
    sub DESTROY {
        my ($self) = @_;
        if ($self->isTesting) {
            my $why = $self->{why};
            printf("# chains of reasoning for %d commits consumed about %d bytes if JSON is what you go by\n",
                   $self->{commitCount},
                   length($self->{json}->encode($self->{why})));
        }
    }
}
;                               # the semicolon keeps web-mode happy

=head1 NAME

git-vgraph - alternative to git-graph(1)

=head1 SYNOPSIS

    git vgraph
        [--all]
        [--decorate[=<short|full|auto|no>]], [--no-decorate]
        [--date-order], [--author-date-order], [--topo-order]
        [--pretty[=<format>]], [--format=<format>], [--oneline]
        [--abbrev-commit], [--no-abbrev-commit]
        [--date=<format>]
        [--name-status]
        [--no-color]
        [--abbrev[=<n>]]
        [--adog|--goad]

    git log --parents ... | git vgraph [<option> ...] --stdin

=head1 DESCRIPTION

I've never liked C<git log --graph>'s output.  Mainly, in that the
branches shift to the left and to the right all the time.  This makes
it more difficult to follow along.

C<git vgraph> provides an alternative that attempts to keep branches
on the same column, making them easier to scan up and down.
Sometimes, master/main or a branch has to shift to another column
though, this cannot be avoided 100% of the time.

This style of output does come at the expense of shifting the C<git
log> text to the right quite some more.

=head1 OPTIONS

=over 4

=item --adog, --goad

Turns on the C<--all>, C<--decorate>, and C<--oneline> options.

The "g" stands for C<--graph>, which is ignored by git-vgraph, which
always displays a graph.

=item --stdin

Instructs git-vgraph to read C<git log --parents> output from stdin,
instead of executing C<git log>.  Escape sequences are recognized and
accounted for.

To generate output compatible with git-vgraph, C<git log> must be
executed with the C<--parents> option specified.

NOTE: In this mode, none of the C<git log> options this program
accepts have any effect.

=back

=head1 GIT LOG OPTIONS ACCEPTED

    --all
    --decorate[=<short|full|auto|no>]
    --no-decorate
    --date-order
    --author-date-order
    --topo-order
    --pretty[=<format>]
    --format=<format>
    --oneline
    --abbrev-commit
    --no-abbrev-commit
    --date=<format>
    --name-status
    --no-color
    --abbrev[=<n>]

    --parents (has no effect)
    --graph (has no effect)

=head1 BUGS

C<git-vgraph> does not accept all C<git log> options.

C<git-vgraph> may fail to parse a line properly if it starts with a
ticket number and all of the following conditions are true:

=over 4

=item *

C<--no-color> or an equivalent is specified, either to this program
directly, or when running L<git-log> to generate the output fed to
this program.

=item *

The ticket number starts with at least as many hex digits as
abbreviated commit ids do.

=item *

C<--oneline> or an equivalent is specified, either to this program
directly, or when running L<git-log> to generate the output fed to
this program.

=back

=head1 AUTHOR

Darren Embry C<dsembry@gmail.com>

=head1 LICENSE

C<git vgraph> is released under the GNU General Public License version
2.0 --- the same terms as Git itself.

https://opensource.org/licenses/GPL-2.0

=cut
