#!/usr/bin/env perl
use warnings;
use strict;
use open qw(locale);
our $PROGNAME = basename($0);

use File::Basename qw(basename);
use POSIX qw(dup2);

our %options;
our @gitCmd = ('git', 'log', '--parents', '--color=always');
sub gitCommandOption {
    my ($name, $state, $value) = @_;
    $value = $value // '';
    my $result = $name;
    if ($state eq 'required') {
        $result .= '=' . $value;
    }
    if ($state eq 'optional') {
        $result .= '=' . $value if $value ne '';
    }
    push(@gitCmd, $result);
}

use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'all'               => sub { gitCommandOption('--all'); },
    'decorate:s'        => sub { gitCommandOption('--decorate', 'optional', $_[1]); },
    'no-decorate'       => sub { gitCommandOption('--no-decorate'); },
    'date-order'        => sub { gitCommandOption('--date-order'); },
    'author-date-order' => sub { gitCommandOption('--author-date-order'); },
    'topo-order'        => sub { gitCommandOption('--topo-order'); },
    'pretty:s'          => sub { gitCommandOption('--pretty', 'optional', $_[1]); },
    'format=s'          => sub { gitCommandOption('--format=', 'required', $_[1]); },
    'abbrev-commit'     => sub { gitCommandOption('--abbrev-commit'); },
    'no-abbrev-commit'  => sub { gitCommandOption('--no-abbrev-commit'); },
    'oneline'           => sub { gitCommandOption('--oneline'); },
    'date=s'            => sub { gitCommandOption('--date=', 'required', $_[1]); },
    'name-status'       => sub { gitCommandOption('--name-status'); },
    'graph'             => sub { }, # no effect

    # special handling
    'parents'           => sub { $options{parents} = 1; },
    'abbrev:s'          => sub { $options{abbrev} = $_[1] if $_[1] ne '';
                                 gitCommandOption('--abbrev', 'optional', $_[1]); },

    # our options
    'adog|goad'         => sub { push(@gitCmd, '--oneline', '--all', '--decorate'); },
    'priority-fight'    => sub { $options{strategy} = 'priority-fight'; },
    'narrow'            => sub { $options{colSep} = 2; },
    'stdin'             => sub { $options{stdin} = 1; },
    'help'              => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage: ${PROGNAME} [<option> ...]
    --adog, --goad   sets --oneline, --all, --decorate
    --stdin          read git log --parents output from stdin
    --help           print this message
git-log(1) options accepted:
    --all
    --decorate[=<short|full|auto|no>], --no-decorate
    --date-order, --author-date-order, --topo-order
    --pretty[=<format>], --format=<format>, --oneline
    --abbrev-commit, --no-abbrev-commit
    --date=<format>
    --name-status
    --abbrev[=<n>]
    --parents
    --graph (has no effect)
END

my $g = My::Git::Graph->new(options => \%options);

STDOUT->autoflush(1);
STDERR->autoflush(1);

# Let's pipe our own output through a pager.
if (-t fileno(\*STDOUT)) {
    my $pager = $ENV{GIT_VGRAPH_PAGER} // $ENV{GIT_PAGER} // $ENV{PAGER} // 'less';
    my ($childIn, $parentOut);
    pipe($childIn, $parentOut) or die("pipe: $!");
    my $pid = fork();
    die("fork: $!") if !defined $pid;
    if ($pid) {
        dup2(fileno($childIn), 0) or die("dup2: $!");
        exec($pager) or die("exec: $!");
    }
    dup2(fileno($parentOut), 1) or die("dup2: $!");
    $g->{options}->{isPaging} = 1;
}

if ($options{stdin}) {
    while (<>) {
        $g->parseLine($_);
    }
    $g->eof();
} else {
    push(@gitCmd, @ARGV);
    my $ph;
    open($ph, '-|', @gitCmd) or die("unable to execute git log: $!\n");
    while (<$ph>) {
        $g->parseLine($_);
    }
    $g->eof();
}

package My::Git::Graph {
    use Text::Tabs qw(expand);
    use List::Util qw(min max uniq);
    our $RX_ESCAPE;
    BEGIN {
        $RX_ESCAPE = qr{\e\[[0-9;]*m};
    }
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{strategy} //= $self->{options}->{strategy};
        $self->{colSep} //= ($self->{options}->{colSep} // 3);
        $self->{abbrev} //= ($self->{options}->{abbrev} // 8);
        $self->{bullet} //= "\N{BLACK CIRCLE}";
        $self->{pri} = My::PriorityFight->new() if $self->usingPriorityFight;
        $self->{printer} = My::Printer->new();
        $self->{printer}->{color} = 0 if !-t 1 && !$self->{options}->{isPaging};
        return $self;
    }
    sub parseLine {
        my ($self, $line) = @_;
        $line =~ s{\R\z}{};    # safer than chomp regarding \r\n vs \n
        local $_ = $line;
        $_ = expand($_);
        my $RX_COMMIT_ID = qr{[[:xdigit:]]{$self->{abbrev},}}x;
        if (m{^(?<esc1>${RX_ESCAPE})?
              (commit[ ])?
              (?<commitids>(?:${RX_COMMIT_ID})(?:[ ](?:${RX_COMMIT_ID}))*\b)
              (?<esc2>\s*${RX_ESCAPE})?
              (?<remainder>.*)$}x) {
            my $esc1      = $+{esc1};
            my $commitids = $+{commitids};
            my $esc2      = $+{esc2};
            my $remainder = $+{remainder};
            my @commitids = grep { m{\S} } split(qr{\s+}, $commitids);
            $self->startCommit(@commitids);
            if (!$self->{options}->{parents}) {
                $line = ($esc1 // '') . $commitids[0] . ($esc2 // '') . $remainder;
            }
            $self->commitLogLine($line);
        } else {
            $self->commitLogLine($line);
        }
    }
    sub startCommit {
        my ($self, $commit, $firstParent, @otherParents) = @_;
        $self->{printer}->flush();
        my $reserved = $self->{RC} //= {};
        my $columns  = $self->{C} //= {};
        my $state1   = { %$columns };
        my $state2;
        if (!defined $columns->{$commit}) {
            $columns->{$commit} = $self->newColumn($columns);
            $state1->{$commit} = $columns->{$commit};
            if (defined $self->{orphaned}) {
                # if previous commit A had no parents and this commit B is
                # assigned same column, insert a "blank" line to render
                # properly, and not mislead people that A's parent is B.
                if ($columns->{$commit} == $self->{orphaned}) {
                    $self->{printer}->printLeft($self->{orphanLine});
                    $self->{printer}->printRight('');
                }
                delete $self->{orphanLine};
                delete $self->{orphaned};
            }
        }
        if (!defined $firstParent) {
            if ($self->usingPriorityFight) {
                $self->{pri}->remove($commit);
            }
            $self->{orphaned} = $state1->{$commit};
            delete $state1->{$commit};
            my $maxCol = max grep { defined $_ } values %$columns;
            my $line1 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
            my $line2 = $self->verticalGraphLine($maxCol, $state1);
            $self->{orphanLine} = $line2; # may need later
            $self->{printer}->setLeftFill($line2);
            $self->{printer}->printLeft($line1);
            %$columns = %$state1;
            return;
        }

        $state1->{$firstParent} //= $columns->{$commit};
        foreach my $otherParent (@otherParents) {
            $state1->{$otherParent} //= $self->newColumn($state1);
        }

        if ($self->usingPriorityFight) {
            # normally if a commit and its first parent are assigned
            # to different columns, we move from current commit's
            # column $col1 to the first parent's column $col2.
            my $col1 = $state1->{$commit};
            my $col2 = $state1->{$firstParent};
            if ($col1 ne $col2) {
                my ($winner, $loser) = $self->{pri}->winner($commit, $firstParent);
                if (defined $winner && $state1->{$winner} == $col1) {
                    # we move first parent from $col2 to current
                    # commit's column $col1
                    $state2 = { %$state1 };
                }
            }
        }

        my $maxCol = max grep { defined $_ } (values(%$columns), values(%$state1));
        my @diagLines1;
        my @diagLines2;
        my $diagLinesDrawn = 0;
        if ($self->usingPriorityFight) {
            if (defined $state2) {
                $diagLinesDrawn = 1;
                my $col1 = $state1->{$commit};
                my $col2 = $state1->{$firstParent};

                # leave first parent ($col2) where it is, we're moving that next
                my @verticalColumns = ($col2, (map { $columns->{$_} }
                                               grep { defined $state1->{$_} && $columns->{$_} == $state1->{$_} }
                                               keys %$columns));
                my @childColumns = map { $state1->{$_} } @otherParents;
                @diagLines1 = $self->drawGraphLines(
                    mode => 'diagonals',
                    maxCol => $maxCol,
                    verticalColumns => [@verticalColumns],
                    parentColumn => $columns->{$commit},
                    childColumns => [@childColumns],
                );

                # now we move first parent $col2 to $col1
                @verticalColumns = ($col1, (grep { $_ != $col2 } values %$state1));
                @diagLines2 = $self->drawGraphLines(
                    mode => 'diagonals',
                    maxCol => $maxCol,
                    verticalColumns => [@verticalColumns],
                    parentColumn => $col2,
                    childColumns => [$col1],
                );

                $state2->{$firstParent} = $state2->{$commit};
                delete $state2->{$commit};
            }
        }
        if (!$diagLinesDrawn) {
            $diagLinesDrawn = 1;
            delete $state1->{$commit};
            my @verticalColumns = (map { $columns->{$_} }
                                   grep { defined $state1->{$_} && $columns->{$_} == $state1->{$_} }
                                   keys %$columns);
            my @childColumns = map { $state1->{$_} } ($firstParent, @otherParents);
            @diagLines1 = $self->drawGraphLines(
                mode => 'diagonals',
                maxCol => $maxCol,
                verticalColumns => [@verticalColumns],
                parentColumn => $columns->{$commit},
                childColumns => [@childColumns],
            );
        }
        my $fillLine = $self->verticalGraphLine($maxCol, $state2 // $state1);
        my $line0 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
        $self->{printer}->setLeftFill($fillLine);
        $self->{printer}->printLeft($line0);
        foreach my $diagLine (@diagLines1, @diagLines2) {
            $self->{printer}->printLeft($diagLine);
        }
        if ($self->usingPriorityFight) {
            $self->{pri}->add($commit, $firstParent, @otherParents);
            $self->{pri}->replace($commit, $firstParent, @otherParents);
            if (defined $state2) {
                %$columns = %$state2;
            } else {
                %$columns = %$state1;
            }
        } else {
            %$columns = %$state1;
        }
    }
    sub commitLogLine {
        my ($self, $line) = @_;
        $self->{printer}->printRight($line);
    }
    sub newColumn {
        my ($self, @states) = @_;
        my @columns = grep { defined $_ } map { (values(%$_)) } @states;
        my %columns = map { ($_ => 1) } @columns;
        for (my $i = 0; ; $i += 1) {
            if (!$columns{$i}) {
                return $i;
            }
        }
    }
    sub verticalGraphLine {
        my ($self, $maxCol, $A, $mark) = @_;
        my @vcol = grep { defined $_ } values(%$A);
        return $self->drawGraphLines(
            maxCol => $maxCol,
            mode => 'verticals',
            verticalColumns => \@vcol,
            markColumn => $mark,
        );
    }
    sub drawGraphLines {
        my ($self, %args) = @_;

        my $mode            = $args{mode};
        my $maxCol          = $args{maxCol};
        my @verticalColumns = eval { @{$args{verticalColumns}} };
        my $parentColumn    = $args{parentColumn};
        my @childColumns    = eval { @{$args{childColumns}} };
        my $markColumn      = $args{markColumn};

        if ($mode eq 'verticals') {
            return if !scalar @verticalColumns && !defined $markColumn;
        }

        my $colSep = $self->{colSep};
        my $useLine1;
        my $useLine2;
        my $line1 = ' ' x ($maxCol * $colSep + 1);
        my $line2 = ' ' x ($maxCol * $colSep + 1);
        my @leftColumns  = grep { $_ < $parentColumn } @childColumns;
        my @rightColumns = grep { $_ > $parentColumn } @childColumns;

        if (defined $parentColumn) {
            if (scalar @leftColumns) {
                $useLine1 = 1;
                substr($line1, $parentColumn * $colSep - 1, 1) = '/';
                my $leftmostColumn = min @leftColumns;
                foreach my $column (@leftColumns) {
                    next if $column == $parentColumn - 1 && $colSep < 3;
                    $useLine2 = 1;
                    substr($line2, $column * $colSep + 1, 1) = '/';
                }
                my $pos1 = $leftmostColumn * $colSep + 2;
                my $pos2 = $parentColumn * $colSep - 2;
                if ($pos1 <= $pos2) {
                    substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
                }
            }
            if (scalar @rightColumns) {
                $useLine1 = 1;
                substr($line1, $parentColumn * $colSep + 1, 1) = '\\';
                my $rightmostColumn = max @rightColumns;
                foreach my $column (@rightColumns) {
                    next if $column == $parentColumn + 1 && $colSep < 3;
                    $useLine2 = 1;
                    substr($line2, $column * $colSep - 1, 1) = '\\';
                }
                my $pos1 = $parentColumn * $colSep + 2;
                my $pos2 = $rightmostColumn * $colSep - 2;
                if ($pos1 <= $pos2) {
                    substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
                }
            }
            if (grep { $parentColumn == $_ } @childColumns) {
                substr($line1, $parentColumn * $colSep, 1) = '|';
                substr($line2, $parentColumn * $colSep, 1) = '|';
            }
        }
        foreach my $column (@verticalColumns) {
            substr($line1, $column * $colSep, 1) = '|';
            substr($line2, $column * $colSep, 1) = '|';
        }
        if (defined $markColumn) {
            my $bullet = $self->{bullet};
            substr($line1, $markColumn * $colSep, 1) = $bullet;
            $line1 =~ s{\Q$bullet\E}{\e[1;33m$&\e[m}g;
        }
        if ($mode eq 'diagonals') {
            return ($line1, $line2) if $useLine2;
            return ($line1) if $useLine1;
            return ();
        }
        if ($mode eq 'verticals') {
            return $line1;
        }
    }
    sub usingPriorityFight {
        my ($self) = @_;
        return defined $self->{strategy} && $self->{strategy} eq 'priority-fight';
    }
    sub eof {
        my ($self) = @_;
        $self->{printer}->flush();
    }
};                              # the semicolon keeps web-mode happy

package My::PriorityFight {
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{pri} = {};
        return $self;
    }
    sub winner {
        my ($self, $a, $b) = @_;
        my $pri = $self->{pri};
        if ($pri->{$a}->{$b}) {
            return ($a, $b) if wantarray;
            return  $a;
        }
        if ($pri->{$b}->{$a}) {
            return ($b, $a) if wantarray;
            return  $b;
        }
        return;
    }
    sub as_string {
        my ($self) = @_;
        my $pri = $self->{pri};
        my @rules;
        foreach my $a (keys %$pri) {
            foreach my $b (keys %{$pri->{$a}}) {
                push(@rules, sprintf("%s > %s [%d]", $a, $b, $pri->{$a}->{$b}));
            }
        }
        return join(' ', @rules);
    }
    sub add {
        my ($self, $commit, $a, @b) = @_;
        my $pri = $self->{pri};
        foreach my $b (@b) {
            if ($pri->{$a}->{$b}) { next; }
            if ($pri->{$b}->{$a}) { next; }
            if ($a eq $b)         { next; }
            $pri->{$a}->{$b} = 1;
        }
    }
    sub replace {
        my ($self, $a, $b, @p) = @_;
        my $pri = $self->{pri};
        return $self->priorityUnmention($a) if !defined $b;
        foreach my $x (keys %{$pri->{$a}}) {
            delete $pri->{$a}->{$x};
            if ($pri->{$b}->{$x}) { next; }
            if ($pri->{$x}->{$b}) { next; }
            if ($b eq $x)         { next; }
            $pri->{$b}->{$x} = 1;
        }
        delete $pri->{$a} if !scalar keys %{$pri->{$a}};
        foreach my $x (keys %$pri) {
            if ($pri->{$x}->{$a}) {
                delete $pri->{$x}->{$a};
                if ($pri->{$b}->{$x}) { next; }
                if ($pri->{$x}->{$b}) { next; }
                if ($x eq $b)         { next; }
                $pri->{$x}->{$b} = 1;
            }
        }
    }
    sub remove {
        my ($self, $a) = @_;
        my $pri = $self->{pri};
        delete $pri->{$a};
        foreach my $b (keys %$pri) {
            delete $pri->{$b}->{$a};
            delete $pri->{$b} if !scalar keys %{$pri->{$b}};
        }
    }
};

package My::Printer {
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{minSpace} //= 6;
        $self->{minCol} //= 24;
        $self->{color} //= 1;
        $self->{leftLines} = [];
        $self->{rightLines} = [];
        return $self;
    }
    sub setLeftFill {
        my ($self, $text) = @_;
        $self->{leftFill} = $text;
    }
    sub printLeft {
        my ($self, $text) = @_;
        push(@{$self->{leftLines}}, $text);
        $self->printOut();
    }
    sub printRight {
        my ($self, $text) = @_;
        push(@{$self->{rightLines}}, $text);
        $self->printOut();
    }
    sub printOut {
        my ($self) = @_;
        my $L = $self->{leftLines};
        my $R = $self->{rightLines};
        while (scalar @$L && scalar @$R) {
            my $left = shift(@$L);
            my $right = shift(@$R);
            $self->printLine($left, $right);
        }
    }
    sub flush {
        my ($self) = @_;
        my $L = $self->{leftLines};
        my $R = $self->{rightLines};
        $self->printOut();
        while (scalar @$L || scalar @$R) {
            my $left = shift(@$L);
            my $right = shift(@$R);
            $self->printLine($left // $self->{leftFill} // '', $right);
        }
    }
    sub printLine {
        my ($self, $left, $right) = @_;
        return if !defined $left && !defined $right;
        $left //= '';
        $right //= '';
        $left .= ' ' x $self->{minSpace};
        my $len = printedLength($left);
        if ($len < $self->{minCol}) {
            $left .= ' ' x ($self->{minCol} - $len);
        }
        if (!$self->{color}) {
            $left  =~ s{\e\[[0-9;]*m}{}g;
            $right =~ s{\e\[[0-9;]*m}{}g;
        }
        print($left, $right, "\n");
    }
    sub printedLength {
        my ($string) = @_;
        $string =~ s{\e\[[0-9;]*m}{}g;
        return length $string;
    }
};

=head1 NAME

git-vgraph - alternative to git-graph(1)

=head1 SYNOPSIS

    git vgraph
        [--all]
        [--decorate[=<short|full|auto|no>]], [--no-decorate]
        [--date-order], [--author-date-order], [--topo-order]
        [--pretty[=<format>]], [--format=<format>], [--oneline]
        [--abbrev-commit], [--no-abbrev-commit]
        [--date=<format>]
        [--name-status]
        [--abbrev[=<n>]]
        [--adog|--goad]

    git log --parents ... | git vgraph [<option> ...] --stdin

=head1 DESCRIPTION

I've never liked C<git log --graph>'s output.  Mainly, in that the
branches shift to the left and to the right all the time.  This makes
it more difficult to follow along.

C<git vgraph> provides an alternative that attempts to keep branches
on the same column, making them easier to scan up and down.
Sometimes, master/main or a branch has to shift to another column
though, this cannot be avoided 100% of the time.

This style of output does come at the expense of shifting the C<git
log> text to the right quite some more.

=head1 OPTIONS

=over 4

=item --adog, --goad

Turns on the C<--all>, C<--decorate>, and C<--oneline> options.

The "g" stands for C<--graph>, which is ignored by git-vgraph, which
always displays a graph.

=item --stdin

Instructs git-vgraph to read C<git log --parents> output from stdin,
instead of executing C<git log>.  Escape sequences are recognized and
accounted for.

To generate output compatible with git-vgraph, C<git log> must be
executed with the C<--parents> option specified.

NOTE: In this mode, none of the C<git log> options this program
accepts have any effect.

=back

=head1 GIT LOG OPTIONS ACCEPTED

    --all
    --decorate[=<short|full|auto|no>]
    --no-decorate
    --date-order
    --author-date-order
    --topo-order
    --pretty[=<format>]
    --format=<format>
    --oneline
    --abbrev-commit
    --no-abbrev-commit
    --date=<format>
    --name-status
    --abbrev[=<n>]
    --parents

    --graph (has no effect)

=head1 BUGS

C<git-vgraph> does not accept all C<git log> options.

C<git-vgraph> may fail to parse a line properly if it starts with a
ticket number and all of the following conditions are true:

=over 4

=item *

C<--no-color> or an equivalent is specified when running L<git-log> to
generate the output fed to this program.

=item *

The ticket number starts with at least as many hex digits as
abbreviated commit ids do.

=item *

C<--oneline> or an equivalent is specified, either to this program
directly, or when running L<git-log> to generate the output fed to
this program.

=back

=head1 AUTHOR

Darren Embry C<dsembry@gmail.com>

=head1 LICENSE

C<git vgraph> is released under the GNU General Public License version
2.0 --- the same terms as Git itself.

https://opensource.org/licenses/GPL-2.0

=cut
