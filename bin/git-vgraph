#!/usr/bin/env perl
use warnings;
use strict;
use open qw(locale);
our $PROGNAME = basename($0);

use File::Basename qw(basename);
use POSIX qw(dup2);

STDOUT->autoflush(1);
STDERR->autoflush(1);

our %options;
our @gitCmd = ('git', 'log', '--parents', '--color=always');

use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'all'               => sub { push(@gitCmd, '--all'); },
    'decorate:s'        => sub { if ($_[1] =~ m{\S}) { push(@gitCmd, '--decorate=' . $_[1]); } else { push(@gitCmd, '--decorate'); } },
    'no-decorate'       => sub { push(@gitCmd, '--no-decorate'); },
    'date-order'        => sub { push(@gitCmd, '--date-order'); },
    'author-date-order' => sub { push(@gitCmd, '--author-date-order'); },
    'topo-order'        => sub { push(@gitCmd, '--topo-order'); },
    'pretty:s'          => sub { if ($_[1] =~ m{\S}) { push(@gitCmd, '--pretty=' . $_[1]); } else { push(@gitCmd, '--pretty'); } },
    'format=s'          => sub { push(@gitCmd, '--format=' . $_[1]); },
    'abbrev-commit'     => sub { push(@gitCmd, '--abbrev-commit'); },
    'no-abbrev-commit'  => sub { push(@gitCmd, '--no-abbrev-commit'); },
    'oneline'           => sub { push(@gitCmd, '--oneline'); },
    'date=s'            => sub { push(@gitCmd, '--date=' . $_[1]); },
    'parents'           => sub { $options{parents} = 1; },
    'name-status'       => sub { push(@gitCmd, '--name-status'); },
    'abbrev:s'          => sub { $options{abbrev} = $_[1] if $_[1] =~ m{\S};
                                 if ($_[1] =~ m{\S}) { push(@gitCmd, '--abbrev=' . $_[1]); } else { push(@gitCmd, '--abbrev'); } },
    'graph'             => sub { }, # no effect
    'adog|goad'         => sub { push(@gitCmd, '--oneline', '--all', '--decorate'); },

    # our options
    'narrow'            => sub { $options{colSep} = 2; },
    'stdin'             => sub { $options{stdin} = 1; },
    'help'              => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage: ${PROGNAME} [<option> ...]
    --adog, --goad   sets --oneline, --all, --decorate
    --stdin          read git log --parents output from stdin
    --help           print this message
git-log(1) options accepted:
    --all
    --decorate[=<short|full|auto|no>], --no-decorate
    --date-order, --author-date-order, --topo-order
    --pretty[=<format>], --format=<format>, --oneline
    --abbrev-commit, --no-abbrev-commit
    --date=<format>
    --name-status
    --no-color
    --abbrev[=<n>]
    --parents, --graph (have no effect)
END

my $g = My::Git::Graph->new(options => \%options);

# Let's pipe our own output through a pager.
if (-t fileno(\*STDOUT)) {
    my $pager = $ENV{GIT_VGRAPH_PAGER} // $ENV{GIT_PAGER} // $ENV{PAGER} // 'less';
    my ($childIn, $parentOut);
    pipe($childIn, $parentOut) or die("pipe: $!");
    my $pid = fork();
    die("fork: $!") if !defined $pid;
    if ($pid) {
        dup2(fileno($childIn), 0) or die("dup2: $!");
        exec($pager) or die("exec: $!");
    }
    dup2(fileno($parentOut), 1) or die("dup2: $!");
    $g->{options}->{isPaging} = 1;
}

if ($options{stdin}) {
    while (<>) {
        $g->parseLine($_);
    }
    $g->eof();
} else {
    push(@gitCmd, @ARGV);
    my $ph;
    open($ph, '-|', @gitCmd) or die("unable to execute git log: $!\n");
    while (<$ph>) {
        $g->parseLine($_);
    }
    $g->eof();
}

package My::Git::Graph {
    use Text::Tabs qw(expand);
    use List::Util qw(min max uniq);
    use JSON;
    our $RX_ESCAPE;
    BEGIN {
        $RX_ESCAPE = qr{\e\[[0-9;]*m};
    }
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{strategy} = undef;
        $self->{minCol} //= 24;
        $self->{minSpace} //= 6;
        $self->{graphLines} = [];
        $self->{textLines} = [];
        $self->{fillLine} = '';
        $self->{colSep} //= ($self->{options}->{colSep} // 3);
        $self->{abbrev} //= ($self->{options}->{abbrev} // 8);
        $self->{bullet} = "\N{BLACK CIRCLE}";
        $self->{abbrev} //= 8;
        $self->{pri} = My::PriorityFight->new() if $self->usingPriorityFight;
        $self->{json} = JSON->new()->ascii(1)->pretty(0)->canonical(1);
        $self->{commitCount} = 0;
        $self->{ruleCount} = 0;
        $self->{printer} = My::Printer->new();
        $self->{printer}->{color} = 0 if !-t 1 && !$self->{options}->{isPaging};
        return $self;
    }
    sub parseLine {
        my ($self, $line) = @_;
        $line =~ s{\R\z}{};    # safer than chomp regarding \r\n vs \n
        local $_ = $line;
        $_ = expand($_);
        my $RX_COMMIT_ID = qr{[[:xdigit:]]{$self->{abbrev},}}x;
        if (m{^(?<esc1>${RX_ESCAPE})?
              (commit[ ])?
              (?<commitids>(?:${RX_COMMIT_ID})(?:[ ](?:${RX_COMMIT_ID}))*\b)
              (?<esc2>\s*${RX_ESCAPE})?
              (?<remainder>.*)$}x) {
            my $esc1      = $+{esc1};
            my $commitids = $+{commitids};
            my $esc2      = $+{esc2};
            my $remainder = $+{remainder};
            my @commitids = grep { m{\S} } split(qr{\s+}, $commitids);
            $self->startCommit(@commitids);
            if (!$self->{options}->{parents}) {
                $line = ($esc1 // '') . $commitids[0] . ($esc2 // '') . $remainder;
            }
            $self->commitLogLine($line);
        } else {
            $self->commitLogLine($line);
        }
    }
    sub startCommit {
        my ($self, $commit, $firstParent, @otherParents) = @_;
        $self->{commitCount} += 1;
        $self->{printer}->flush();
        my $reserved = $self->{RC} //= {};
        my $columns  = $self->{C} //= {};
        my $state1   = { %$columns };
        my $state2;
        if (!defined $columns->{$commit}) {
            $columns->{$commit} = $self->newColumn($columns);
            $state1->{$commit} = $columns->{$commit};
            if (defined $self->{orphaned}) {
                # if previous commit A had no parents and this commit B is
                # assigned same column, insert a "blank" line to render
                # properly, and not mislead people that A's parent is B.
                if ($columns->{$commit} == $self->{orphaned}) {
                    $self->{printer}->printLeft($self->{orphanLine});
                    $self->{printer}->printRight('');
                }
                delete $self->{orphanLine};
                delete $self->{orphaned};
            }
        }
        if (!defined $firstParent) {
            if ($self->usingPriorityFight) {
                $self->{pri}->remove($commit);
            }
            $self->{orphaned} = $state1->{$commit};
            delete $state1->{$commit};
            my $maxCol = max grep { defined $_ } values %$columns;
            my $line1 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
            my $line2 = $self->verticalGraphLine($maxCol, $state1);
            $self->{orphanLine} = $line2; # may need later
            $self->{printer}->setLeftFill($line2);
            $self->{printer}->printLeft($line1);
            %$columns = %$state1;
            return;
        }

        if ($self->usingPriorityFight) {
            my $firstParentWasAllocated = defined $state1->{$firstParent};
            if (!$firstParentWasAllocated) {
                $state1->{$firstParent} = $columns->{$commit};
            }
            foreach my $otherParent (@otherParents) {
                if (!defined $state1->{$otherParent}) {
                    $state1->{$otherParent} = $self->newColumn($state1);
                }
            }
            if ($firstParentWasAllocated) {
                my $col1 = $state1->{$commit};
                my $col2 = $state1->{$firstParent};
                if ($col1 ne $col2) {
                    my ($winner, $loser) = $self->{pri}->winner($commit, $firstParent);
                    if (defined $winner && $state1->{$winner} == $col1) {
                        $state2 = { %$state1 };
                    }
                }
            }
        } else {
            $state1->{$firstParent} //= $columns->{$commit};
            foreach my $otherParent (@otherParents) {
                if (!defined $state1->{$otherParent}) {
                    $state1->{$otherParent} = $self->newColumn($state1);
                }
            }
        }

        my $maxCol = max grep { defined $_ } (values(%$columns), values(%$state1));
        my @diagLines1;
        my @diagLines2;
        if ($self->usingPriorityFight) {
            if (defined $state2) {
                my $col1 = $state1->{$commit};
                my $col2 = $state1->{$firstParent};
                @diagLines1 = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, @otherParents);

                # You are not expected to understand this.
                # BEGIN HACK
                delete $state2->{$firstParent};
                @diagLines2 = $self->diagonalGraphLines($maxCol, $state1, $state2, $firstParent, $commit);
                $state2->{$firstParent} = $state2->{$commit};
                delete $state2->{$commit};
                # END HACK
            } else {
                delete $state1->{$commit};
                @diagLines1 = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, $firstParent, @otherParents);
            }
        } else {
            delete $state1->{$commit};
            @diagLines1 = $self->diagonalGraphLines($maxCol, $columns, $state1, $commit, $firstParent, @otherParents);
        }
        my $fillLine = $self->verticalGraphLine($maxCol, $state2 // $state1);
        my $line0 = $self->verticalGraphLine($maxCol, $columns, $columns->{$commit});
        $self->{printer}->setLeftFill($fillLine);
        $self->{printer}->printLeft($line0);
        foreach my $diagLine (@diagLines1, @diagLines2) {
            $self->{printer}->printLeft($diagLine);
        }
        if ($self->usingPriorityFight) {
            $self->{pri}->add($commit, $firstParent, @otherParents);
            $self->{pri}->replace($commit, $firstParent, @otherParents);
            if (defined $state2) {
                %$columns = %$state2;
            } else {
                %$columns = %$state1;
            }
        } else {
            %$columns = %$state1;
        }
    }
    sub commitLogLine {
        my ($self, $line) = @_;
        $self->{printer}->printRight($line);
    }
    sub newColumn {
        my ($self, @states) = @_;
        my @columns = grep { defined $_ } map { (values(%$_)) } @states;
        my %columns = map { ($_ => 1) } @columns;
        for (my $i = 0; ; $i += 1) {
            if (!$columns{$i}) {
                return $i;
            }
        }
    }
    sub verticalGraphLine {
        my ($self, $maxCol, $A, $mark) = @_;
        my $colSep = $self->{colSep};
        my @col = grep { defined $_ } values(%$A);
        return if !scalar @col;
        my $line = ' ' x ($maxCol * $colSep + 1);
        foreach my $col (@col) {
            substr($line, $col * $colSep, 1) = '|';
        }
        my $bullet = $self->{bullet};
        if (defined $mark) {
            substr($line, $mark * $colSep, 1) = $bullet;
        }
        $line =~ s{\Q$bullet\E}{\e[1;33m$&\e[m}g;
        return $line;
    }
    sub diagonalGraphLines {
        my ($self, $maxCol, $columns, $state1, $commit, @parents) = @_;
        if (!defined $commit && !scalar @parents) {
            return ();
        }
        my $colSep = $self->{colSep};
        my $useLine1;     # true if there's any diagonal lines at all
        my $useLine2;     # true if line2 is needed to render properly
        my $line1 = ' ' x ($maxCol * $colSep + 1);
        my $line2 = ' ' x ($maxCol * $colSep + 1);
        my @parentColumns = map { $state1->{$_} } @parents;
        my $thisColumn = $columns->{$commit};
        my @leftColumns  = grep { $_ < $thisColumn } @parentColumns;
        my @rightColumns = grep { $_ > $thisColumn } @parentColumns;

        # draw leftward downward diagonals
        if (scalar @leftColumns) {
            $useLine1 = 1;
            substr($line1, $thisColumn * $colSep - 1, 1) = '/';
            my $leftmostColumn = min @leftColumns;
            foreach my $column (@leftColumns) {
                next if $column == $thisColumn - 1 && $colSep < 3;
                $useLine2 = 1;
                substr($line2, $column * $colSep + 1, 1) = '/';
            }
            my $pos1 = $leftmostColumn * $colSep + 2;
            my $pos2 = $thisColumn * $colSep - 2;
            if ($pos1 <= $pos2) {
                substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
            }
        }

        # draw rightward downward diagonals
        if (scalar @rightColumns) {
            $useLine1 = 1;
            substr($line1, $thisColumn * $colSep + 1, 1) = '\\';
            my $rightmostColumn = max @rightColumns;
            foreach my $column (@rightColumns) {
                next if $column == $thisColumn + 1 && $colSep < 3;
                $useLine2 = 1;
                substr($line2, $column * $colSep - 1, 1) = '\\';
            }
            my $pos1 = $thisColumn * $colSep + 2;
            my $pos2 = $rightmostColumn * $colSep - 2;
            if ($pos1 <= $pos2) {
                substr($line1, $pos1, $pos2 - $pos1 + 1) = '_' x ($pos2 - $pos1 + 1);
            }
        }

        # is one of the parents this column?
        if (grep { $thisColumn == $_ } @parentColumns) {
            substr($line1, $thisColumn * $colSep, 1) = '|';
            substr($line2, $thisColumn * $colSep, 1) = '|';
        }

        my @verticalCommits = grep { defined $columns->{$_} } keys %$state1;
        my @verticalColumns = map { $columns->{$_} } @verticalCommits;
        foreach my $column (@verticalColumns) {
            substr($line1, $column * $colSep, 1) = '|';
            substr($line2, $column * $colSep, 1) = '|';
        }
        return ($line1, $line2) if $useLine2;
        return ($line1) if $useLine1;
        return ();
    }
    sub usingPriorityFight {
        my ($self) = @_;
        return defined $self->{strategy} && $self->{strategy} eq 'priority-fight';
    }
    sub eof {
        my ($self) = @_;
        $self->{printer}->flush();
    }
};                              # the semicolon keeps web-mode happy

package My::PriorityFight {
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{pri} = {};
        return $self;
    }
    sub winner {
        my ($self, $a, $b) = @_;
        my $pri = $self->{pri};
        if ($pri->{$a}->{$b}) {
            return ($a, $b) if wantarray;
            return  $a;
        }
        if ($pri->{$b}->{$a}) {
            return ($b, $a) if wantarray;
            return  $b;
        }
        return;
    }
    sub as_string {
        my ($self) = @_;
        my $pri = $self->{pri};
        my @rules;
        foreach my $a (keys %$pri) {
            foreach my $b (keys %{$pri->{$a}}) {
                push(@rules, sprintf("%s > %s [%d]", $a, $b, $pri->{$a}->{$b}));
            }
        }
        return join(' ', @rules);
    }
    sub add {
        my ($self, $commit, $a, @b) = @_;
        my $pri = $self->{pri};
        foreach my $b (@b) {
            if ($pri->{$a}->{$b}) { next; }
            if ($pri->{$b}->{$a}) { next; }
            if ($a eq $b)         { next; }
            $pri->{$a}->{$b} = 1;
        }
    }
    sub replace {
        my ($self, $a, $b, @p) = @_;
        my $pri = $self->{pri};
        return $self->priorityUnmention($a) if !defined $b;
        foreach my $x (keys %{$pri->{$a}}) {
            delete $pri->{$a}->{$x};
            if ($pri->{$b}->{$x}) { next; }
            if ($pri->{$x}->{$b}) { next; }
            if ($b eq $x)         { next; }
            $pri->{$b}->{$x} = 1;
        }
        delete $pri->{$a} if !scalar keys %{$pri->{$a}};
        foreach my $x (keys %$pri) {
            if ($pri->{$x}->{$a}) {
                delete $pri->{$x}->{$a};
                if ($pri->{$b}->{$x}) { next; }
                if ($pri->{$x}->{$b}) { next; }
                if ($x eq $b)         { next; }
                $pri->{$x}->{$b} = 1;
            }
        }
    }
    sub remove {
        my ($self, $a) = @_;
        my $pri = $self->{pri};
        delete $pri->{$a};
        foreach my $b (keys %$pri) {
            delete $pri->{$b}->{$a};
            delete $pri->{$b} if !scalar keys %{$pri->{$b}};
        }
    }
};

package My::Printer {
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        $self->{minSpace} //= 6;
        $self->{minCol} //= 24;
        $self->{color} //= 1;
        $self->{leftLines} = [];
        $self->{rightLines} = [];
        return $self;
    }
    sub setLeftFill {
        my ($self, $text) = @_;
        $self->{leftFill} = $text // '';
    }
    sub printLeft {
        my ($self, $text) = @_;
        push(@{$self->{leftLines}}, $text);
        $self->printOut();
    }
    sub printRight {
        my ($self, $text) = @_;
        push(@{$self->{rightLines}}, $text);
        $self->printOut();
    }
    sub printOut {
        my ($self) = @_;
        my $L = $self->{leftLines};
        my $R = $self->{rightLines};
        while (scalar @$L && scalar @$R) {
            my $left = shift(@$L);
            my $right = shift(@$R);
            $self->printLine($left, $right);
        }
    }
    sub flush {
        my ($self) = @_;
        my $L = $self->{leftLines};
        my $R = $self->{rightLines};
        $self->printOut();
        while (scalar @$L || scalar @$R) {
            my $left = shift(@$L);
            my $right = shift(@$R);
            $self->printLine($left // $self->{fillLine}, $right);
        }
    }
    sub printLine {
        my ($self, $left, $right) = @_;
        return if !defined $left && !defined $right;
        $left //= '';
        $right //= '';
        $right .= ' ' x $self->{minSpace};
        my $len = printedLength($left);
        if ($len < $self->{minCol}) {
            $left .= ' ' x ($self->{minCol} - $len);
        }
        if (!$self->{color}) {
            $left  =~ s{\e\[[0-9;]*m}{}g;
            $right =~ s{\e\[[0-9;]*m}{}g;
        }
        print($left, $right, "\n");
    }
    sub printedLength {
        my ($string) = @_;
        $string =~ s{\e\[[0-9;]*m}{}g;
        return length $string;
    }
};

=head1 NAME

git-vgraph - alternative to git-graph(1)

=head1 SYNOPSIS

    git vgraph
        [--all]
        [--decorate[=<short|full|auto|no>]], [--no-decorate]
        [--date-order], [--author-date-order], [--topo-order]
        [--pretty[=<format>]], [--format=<format>], [--oneline]
        [--abbrev-commit], [--no-abbrev-commit]
        [--date=<format>]
        [--name-status]
        [--no-color]
        [--abbrev[=<n>]]
        [--adog|--goad]

    git log --parents ... | git vgraph [<option> ...] --stdin

=head1 DESCRIPTION

I've never liked C<git log --graph>'s output.  Mainly, in that the
branches shift to the left and to the right all the time.  This makes
it more difficult to follow along.

C<git vgraph> provides an alternative that attempts to keep branches
on the same column, making them easier to scan up and down.
Sometimes, master/main or a branch has to shift to another column
though, this cannot be avoided 100% of the time.

This style of output does come at the expense of shifting the C<git
log> text to the right quite some more.

=head1 OPTIONS

=over 4

=item --adog, --goad

Turns on the C<--all>, C<--decorate>, and C<--oneline> options.

The "g" stands for C<--graph>, which is ignored by git-vgraph, which
always displays a graph.

=item --stdin

Instructs git-vgraph to read C<git log --parents> output from stdin,
instead of executing C<git log>.  Escape sequences are recognized and
accounted for.

To generate output compatible with git-vgraph, C<git log> must be
executed with the C<--parents> option specified.

NOTE: In this mode, none of the C<git log> options this program
accepts have any effect.

=back

=head1 GIT LOG OPTIONS ACCEPTED

    --all
    --decorate[=<short|full|auto|no>]
    --no-decorate
    --date-order
    --author-date-order
    --topo-order
    --pretty[=<format>]
    --format=<format>
    --oneline
    --abbrev-commit
    --no-abbrev-commit
    --date=<format>
    --name-status
    --no-color
    --abbrev[=<n>]

    --parents (has no effect)
    --graph (has no effect)

=head1 BUGS

C<git-vgraph> does not accept all C<git log> options.

C<git-vgraph> may fail to parse a line properly if it starts with a
ticket number and all of the following conditions are true:

=over 4

=item *

C<--no-color> or an equivalent is specified, either to this program
directly, or when running L<git-log> to generate the output fed to
this program.

=item *

The ticket number starts with at least as many hex digits as
abbreviated commit ids do.

=item *

C<--oneline> or an equivalent is specified, either to this program
directly, or when running L<git-log> to generate the output fed to
this program.

=back

=head1 AUTHOR

Darren Embry C<dsembry@gmail.com>

=head1 LICENSE

C<git vgraph> is released under the GNU General Public License version
2.0 --- the same terms as Git itself.

https://opensource.org/licenses/GPL-2.0

=cut
